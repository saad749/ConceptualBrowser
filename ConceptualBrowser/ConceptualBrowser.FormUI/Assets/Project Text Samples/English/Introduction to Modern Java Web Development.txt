Introduction to Modern Java Web Development

Because Java web servers are about as old as the web itself, and there are long, successful, traditions and practices associated with them – traditions which we will soon commence on dismantling – this is perhaps as good a time as any to explain what I mean by “modern” in this series’s title.

In this context, I take “modern” to mean “in accordance with current general software development trends”. These trends aren’t completely arbitrary, and they are consistent with one another. The birth of a very large number of small, young, fast-moving startups, has given rise to a preference of lean development approaches. Those require easier onboarding, fewer installation, deployment and configuration steps, and a convergence of the roles of development and operations. The growing popularity of the cloud encourages certain approaches towards resource management, namely virtualization, either at the hypervisor level or the OS level. OS-level deployment/resource allocation also supports the proliferation of polyglot architectures, which seek to use the right (but possibly different) tool for each job.

Traditional Java web servers – or, in their full-featured incarnation, application servers – have one particular distinguishing feature: the ability to run multiple applications in a single JVM instance. They provide a runtime that is separate from the application. It is upgraded, and installed separately. It can be launched separately. Applications are deployed to a fully configured, possible already running, runtime. While this approach has worked well for quite some time – and you may have good reasons to continue employing it – it is far from modern. Allocating resources among the different applications occupying the server is not simple (if possible at all), and it is certainly incompatible with current trends of using hypervisor- and OS containers to host applications. Tools and techniques designed for hypervisor/OS containers are not effective with multi-app servers. Even if these servers are used to host a single application, their operation is most certainly not modern: installing and configuring the web- or app- server is usually not trivial, and deploying applications to said servers take multiple steps, and may be cumbersome.

The modern approach, that used by practically all other languages and runtime platforms, and increasingly adopted in the Java world, is that of the single-app server. In this kind of server, the web container is embedded in the application (rather than the application being deployed to a web container). This allows for simple deployment, management and configuration, and resource allocation at the OS/hypervisor level. This is why, when modern Java is concerned, application servers (and by that I mean any servlet or full-featured Java EE server designed to run more than one application) – are dead.

Now, the tools and techniques we will survey here are far from comprehensive. Especially when it comes to web, and web-related, development, tools, libraries and frameworks proliferate. Part of the reason for that is that, unlike fields such as embedded development or mainframe applications, web development is popular among all those fast-moving startups I mentioned, as well as hobbyists. These populations are early adopters and like to experiment with new techniques and invent new ones – sometimes in order to get some technological edge, sometimes for learning purposes, and sometimes for more gratuitous self gratification. The outcome is hundreds of libraries, all achieving similar goals, but in slightly different ways. This happens in the Java world, just as it does in other language ecosystems.

Also, we will not discuss “full” web frameworks at all, and by that I mean large MVC frameworks, template systems, or any framework designed for applications that render HTML on the server. There are a few reasons for that: One, I’ve never used any of those, so I certainly cannot comment on their suitability or “modernness”; two, the topic is a complex one, requires much discussion, and has been done elsewhere (see here and here); three, it seems like web development is moving towards client-side rendering and “single-page apps” (with client side frameworks like Angular et al.), essentially adopting an architecture similar to old client-server apps, and relying on HTTP services to transfer data and commands to and from the server. That transition is not complete – in particular, it depends on mobile phone browsers improving their JavaScript performance – but it is near certain that we’ll be seeing less and less HTML generated dynamically on the server. We will, therefore, only discuss frameworks and libraries for HTTP “data” services.